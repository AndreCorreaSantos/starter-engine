
module {
  func.func @main() {
  %0 = "engine.constant"() {value = dense<[1.000000e+00, 2.000000e+00, 3.000000e+00]> : tensor<3xf64>} : () -> memref<3xf64>
  func.return
  }
}

// ------// IR Dump After MyEngineLowering // ---- //

module {
  func.func @main() {
    %cst = arith.constant 3.000000e+00 : f64
    %cst_0 = arith.constant 2.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+00 : f64
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc() : memref<3xf64>
    affine.store %cst_1, %alloc[%c0] : memref<3xf64>
    affine.store %cst_0, %alloc[%c1] : memref<3xf64>
    affine.store %cst, %alloc[%c2] : memref<3xf64>
    return
  }
}


// -----// IR Dump After ConvertAffineToStandard (lower-affine) //----- //
module {
  func.func @main() {
    %cst = arith.constant 3.000000e+00 : f64
    %cst_0 = arith.constant 2.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+00 : f64
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc() : memref<3xf64>
    memref.store %cst_1, %alloc[%c0] : memref<3xf64>
    memref.store %cst_0, %alloc[%c1] : memref<3xf64>
    memref.store %cst, %alloc[%c2] : memref<3xf64>
    return
  }
}


// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
module {
  func.func @main() {
    %cst = arith.constant 3.000000e+00 : f64
    %cst_0 = arith.constant 2.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+00 : f64
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc() : memref<3xf64>
    memref.store %cst_1, %alloc[%c0] : memref<3xf64>
    memref.store %cst_0, %alloc[%c1] : memref<3xf64>
    memref.store %cst, %alloc[%c2] : memref<3xf64>
    return
  }
}


// -----// IR Dump After FlattenMemRef (flatten-memref) //----- //
module {
  func.func @main() {
    %cst = arith.constant 3.000000e+00 : f64
    %cst_0 = arith.constant 2.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+00 : f64
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc() : memref<3xf64>
    memref.store %cst_1, %alloc[%c0] : memref<3xf64>
    memref.store %cst_0, %alloc[%c1] : memref<3xf64>
    memref.store %cst, %alloc[%c2] : memref<3xf64>
    return
  }
}


// -----// IR Dump After HandshakeLegalizeMemrefs (handshake-legalize-memrefs) //----- //
func.func @main() {
  %cst = arith.constant 3.000000e+00 : f64
  %cst_0 = arith.constant 2.000000e+00 : f64
  %cst_1 = arith.constant 1.000000e+00 : f64
  %c2 = arith.constant 2 : index
  %c1 = arith.constant 1 : index
  %c0 = arith.constant 0 : index
  %alloc = memref.alloc() : memref<3xf64>
  memref.store %cst_1, %alloc[%c0] : memref<3xf64>
  memref.store %cst_0, %alloc[%c1] : memref<3xf64>
  memref.store %cst, %alloc[%c2] : memref<3xf64>
  return
}

// -----// IR Dump After SCFToControlFlow (convert-scf-to-cf) //----- //
module {
  func.func @main() {
    %cst = arith.constant 3.000000e+00 : f64
    %cst_0 = arith.constant 2.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+00 : f64
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloc = memref.alloc() : memref<3xf64>
    memref.store %cst_1, %alloc[%c0] : memref<3xf64>
    memref.store %cst_0, %alloc[%c1] : memref<3xf64>
    memref.store %cst, %alloc[%c2] : memref<3xf64>
    return
  }
}


// -----// IR Dump After CFToHandshake (lower-cf-to-handshake) //----- //
module {
  handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
    %0:3 = memory[ld = 0, st = 3] (%dataResult, %addressResult, %dataResult_0, %addressResult_1, %dataResult_2, %addressResult_3) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
    %1 = merge %arg0 : none
    %2 = join %1, %0#0, %0#1, %0#2 : none, none, none, none
    %3 = constant %1 {value = 3.000000e+00 : f64} : f64
    %4 = constant %1 {value = 2.000000e+00 : f64} : f64
    %5 = constant %1 {value = 1.000000e+00 : f64} : f64
    %6 = constant %1 {value = 2 : index} : index
    %7 = constant %1 {value = 1 : index} : index
    %8 = constant %1 {value = 0 : index} : index
    %dataResult, %addressResult = store [%8] %5, %1 : index, f64
    %9 = join %1, %0#0 : none, none
    %dataResult_0, %addressResult_1 = store [%7] %4, %9 : index, f64
    %10 = join %1, %0#0, %0#1 : none, none, none
    %dataResult_2, %addressResult_3 = store [%6] %3, %10 : index, f64
    return %2 : none
  }
}


// -----// IR Dump After HandshakeLowerExtmemToHW (handshake-lower-extmem-to-hw) //----- //
module {
  handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
    %0:3 = memory[ld = 0, st = 3] (%dataResult, %addressResult, %dataResult_0, %addressResult_1, %dataResult_2, %addressResult_3) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
    %1 = merge %arg0 : none
    %2 = join %1, %0#0, %0#1, %0#2 : none, none, none, none
    %3 = constant %1 {value = 3.000000e+00 : f64} : f64
    %4 = constant %1 {value = 2.000000e+00 : f64} : f64
    %5 = constant %1 {value = 1.000000e+00 : f64} : f64
    %6 = constant %1 {value = 2 : index} : index
    %7 = constant %1 {value = 1 : index} : index
    %8 = constant %1 {value = 0 : index} : index
    %dataResult, %addressResult = store [%8] %5, %1 : index, f64
    %9 = join %1, %0#0 : none, none
    %dataResult_0, %addressResult_1 = store [%7] %4, %9 : index, f64
    %10 = join %1, %0#0, %0#1 : none, none, none
    %dataResult_2, %addressResult_3 = store [%6] %3, %10 : index, f64
    return %2 : none
  }
}


// -----// IR Dump After Canonicalizer (canonicalize) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0:3 = memory[ld = 0, st = 3] (%dataResult, %addressResult, %dataResult_0, %addressResult_1, %dataResult_2, %addressResult_3) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %1 = join %arg0, %0#0, %0#1, %0#2 : none, none, none, none
  %2 = constant %arg0 {value = 3.000000e+00 : f64} : f64
  %3 = constant %arg0 {value = 2.000000e+00 : f64} : f64
  %4 = constant %arg0 {value = 1.000000e+00 : f64} : f64
  %5 = constant %arg0 {value = 2 : index} : index
  %6 = constant %arg0 {value = 1 : index} : index
  %7 = constant %arg0 {value = 0 : index} : index
  %dataResult, %addressResult = store [%7] %4, %arg0 : index, f64
  %8 = join %arg0, %0#0 : none, none
  %dataResult_0, %addressResult_1 = store [%6] %3, %8 : index, f64
  %9 = join %arg0, %0#0, %0#1 : none, none, none
  %dataResult_2, %addressResult_3 = store [%5] %2, %9 : index, f64
  return %1 : none
}

// -----// IR Dump After HandshakeMaterializeForksSinks (handshake-materialize-forks-sinks) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0:10 = fork [10] %arg0 : none
  %1:3 = memory[ld = 0, st = 3] (%dataResult, %addressResult, %dataResult_0, %addressResult_1, %dataResult_2, %addressResult_3) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %2:2 = fork [2] %1#1 : none
  %3:3 = fork [3] %1#0 : none
  %4 = join %0#6, %3#2, %2#1, %1#2 : none, none, none, none
  %5 = constant %0#0 {value = 3.000000e+00 : f64} : f64
  %6 = constant %0#1 {value = 2.000000e+00 : f64} : f64
  %7 = constant %0#2 {value = 1.000000e+00 : f64} : f64
  %8 = constant %0#3 {value = 2 : index} : index
  %9 = constant %0#4 {value = 1 : index} : index
  %10 = constant %0#5 {value = 0 : index} : index
  %dataResult, %addressResult = store [%10] %7, %0#7 : index, f64
  %11 = join %0#8, %3#1 : none, none
  %dataResult_0, %addressResult_1 = store [%9] %6, %11 : index, f64
  %12 = join %0#9, %3#0, %2#0 : none, none, none
  %dataResult_2, %addressResult_3 = store [%8] %5, %12 : index, f64
  return %4 : none
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0:10 = fork [10] %arg0 : none
  %1:3 = memory[ld = 0, st = 3] (%dataResult, %addressResult, %dataResult_0, %addressResult_1, %dataResult_2, %addressResult_3) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %2:2 = fork [2] %1#1 : none
  %3:3 = fork [3] %1#0 : none
  %4 = join %0#6, %3#2, %2#1, %1#2 : none, none, none, none
  %5 = constant %0#0 {value = 3.000000e+00 : f64} : f64
  %6 = constant %0#1 {value = 2.000000e+00 : f64} : f64
  %7 = constant %0#2 {value = 1.000000e+00 : f64} : f64
  %8 = constant %0#3 {value = 2 : index} : index
  %9 = constant %0#4 {value = 1 : index} : index
  %10 = constant %0#5 {value = 0 : index} : index
  %dataResult, %addressResult = store [%10] %7, %0#7 : index, f64
  %11 = join %0#8, %3#1 : none, none
  %dataResult_0, %addressResult_1 = store [%9] %6, %11 : index, f64
  %12 = join %0#9, %3#0, %2#0 : none, none, none
  %dataResult_2, %addressResult_3 = store [%8] %5, %12 : index, f64
  return %4 : none
}

// -----// IR Dump After HandshakeInsertBuffers (handshake-insert-buffers) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0 = buffer [2] seq %arg0 : none
  %1:10 = fork [10] %0 : none
  %2 = buffer [2] seq %1#9 : none
  %3 = buffer [2] seq %1#8 : none
  %4 = buffer [2] seq %1#7 : none
  %5 = buffer [2] seq %1#6 : none
  %6 = buffer [2] seq %1#5 : none
  %7 = buffer [2] seq %1#4 : none
  %8 = buffer [2] seq %1#3 : none
  %9 = buffer [2] seq %1#2 : none
  %10 = buffer [2] seq %1#1 : none
  %11 = buffer [2] seq %1#0 : none
  %12:3 = memory[ld = 0, st = 3] (%38, %37, %42, %41, %46, %45) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %13 = buffer [2] seq %12#2 : none
  %14 = buffer [2] seq %12#1 : none
  %15 = buffer [2] seq %12#0 : none
  %16:2 = fork [2] %14 : none
  %17 = buffer [2] seq %16#1 : none
  %18 = buffer [2] seq %16#0 : none
  %19:3 = fork [3] %15 : none
  %20 = buffer [2] seq %19#2 : none
  %21 = buffer [2] seq %19#1 : none
  %22 = buffer [2] seq %19#0 : none
  %23 = join %5, %20, %17, %13 : none, none, none, none
  %24 = buffer [2] seq %23 : none
  %25 = constant %11 {value = 3.000000e+00 : f64} : f64
  %26 = buffer [2] seq %25 : f64
  %27 = constant %10 {value = 2.000000e+00 : f64} : f64
  %28 = buffer [2] seq %27 : f64
  %29 = constant %9 {value = 1.000000e+00 : f64} : f64
  %30 = buffer [2] seq %29 : f64
  %31 = constant %8 {value = 2 : index} : index
  %32 = buffer [2] seq %31 : index
  %33 = constant %7 {value = 1 : index} : index
  %34 = buffer [2] seq %33 : index
  %35 = constant %6 {value = 0 : index} : index
  %36 = buffer [2] seq %35 : index
  %dataResult, %addressResult = store [%36] %30, %4 : index, f64
  %37 = buffer [2] seq %addressResult : index
  %38 = buffer [2] seq %dataResult : f64
  %39 = join %3, %21 : none, none
  %40 = buffer [2] seq %39 : none
  %dataResult_0, %addressResult_1 = store [%34] %28, %40 : index, f64
  %41 = buffer [2] seq %addressResult_1 : index
  %42 = buffer [2] seq %dataResult_0 : f64
  %43 = join %2, %22, %18 : none, none, none
  %44 = buffer [2] seq %43 : none
  %dataResult_2, %addressResult_3 = store [%32] %26, %44 : index, f64
  %45 = buffer [2] seq %addressResult_3 : index
  %46 = buffer [2] seq %dataResult_2 : f64
  return %24 : none
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0 = buffer [2] seq %arg0 : none
  %1:10 = fork [10] %0 : none
  %2 = buffer [2] seq %1#9 : none
  %3 = buffer [2] seq %1#8 : none
  %4 = buffer [2] seq %1#7 : none
  %5 = buffer [2] seq %1#6 : none
  %6 = buffer [2] seq %1#5 : none
  %7 = buffer [2] seq %1#4 : none
  %8 = buffer [2] seq %1#3 : none
  %9 = buffer [2] seq %1#2 : none
  %10 = buffer [2] seq %1#1 : none
  %11 = buffer [2] seq %1#0 : none
  %12:3 = memory[ld = 0, st = 3] (%38, %37, %42, %41, %46, %45) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %13 = buffer [2] seq %12#2 : none
  %14 = buffer [2] seq %12#1 : none
  %15 = buffer [2] seq %12#0 : none
  %16:2 = fork [2] %14 : none
  %17 = buffer [2] seq %16#1 : none
  %18 = buffer [2] seq %16#0 : none
  %19:3 = fork [3] %15 : none
  %20 = buffer [2] seq %19#2 : none
  %21 = buffer [2] seq %19#1 : none
  %22 = buffer [2] seq %19#0 : none
  %23 = join %5, %20, %17, %13 : none, none, none, none
  %24 = buffer [2] seq %23 : none
  %25 = constant %11 {value = 3.000000e+00 : f64} : f64
  %26 = buffer [2] seq %25 : f64
  %27 = constant %10 {value = 2.000000e+00 : f64} : f64
  %28 = buffer [2] seq %27 : f64
  %29 = constant %9 {value = 1.000000e+00 : f64} : f64
  %30 = buffer [2] seq %29 : f64
  %31 = constant %8 {value = 2 : index} : index
  %32 = buffer [2] seq %31 : index
  %33 = constant %7 {value = 1 : index} : index
  %34 = buffer [2] seq %33 : index
  %35 = constant %6 {value = 0 : index} : index
  %36 = buffer [2] seq %35 : index
  %dataResult, %addressResult = store [%36] %30, %4 : index, f64
  %37 = buffer [2] seq %addressResult : index
  %38 = buffer [2] seq %dataResult : f64
  %39 = join %3, %21 : none, none
  %40 = buffer [2] seq %39 : none
  %dataResult_0, %addressResult_1 = store [%34] %28, %40 : index, f64
  %41 = buffer [2] seq %addressResult_1 : index
  %42 = buffer [2] seq %dataResult_0 : f64
  %43 = join %2, %22, %18 : none, none, none
  %44 = buffer [2] seq %43 : none
  %dataResult_2, %addressResult_3 = store [%32] %26, %44 : index, f64
  %45 = buffer [2] seq %addressResult_3 : index
  %46 = buffer [2] seq %dataResult_2 : f64
  return %24 : none
}

// -----// IR Dump After Canonicalizer (canonicalize) //----- //
handshake.func @main(%arg0: none, ...) -> none attributes {argNames = ["in0"], resNames = ["out0"]} {
  %0 = buffer [2] seq %arg0 : none
  %1:10 = fork [10] %0 : none
  %2 = buffer [2] seq %1#9 : none
  %3 = buffer [2] seq %1#8 : none
  %4 = buffer [2] seq %1#7 : none
  %5 = buffer [2] seq %1#6 : none
  %6 = buffer [2] seq %1#5 : none
  %7 = buffer [2] seq %1#4 : none
  %8 = buffer [2] seq %1#3 : none
  %9 = buffer [2] seq %1#2 : none
  %10 = buffer [2] seq %1#1 : none
  %11 = buffer [2] seq %1#0 : none
  %12:3 = memory[ld = 0, st = 3] (%38, %37, %42, %41, %46, %45) {id = 0 : i32, lsq = false} : memref<3xf64>, (f64, index, f64, index, f64, index) -> (none, none, none)
  %13 = buffer [2] seq %12#2 : none
  %14 = buffer [2] seq %12#1 : none
  %15 = buffer [2] seq %12#0 : none
  %16:2 = fork [2] %14 : none
  %17 = buffer [2] seq %16#1 : none
  %18 = buffer [2] seq %16#0 : none
  %19:3 = fork [3] %15 : none
  %20 = buffer [2] seq %19#2 : none
  %21 = buffer [2] seq %19#1 : none
  %22 = buffer [2] seq %19#0 : none
  %23 = join %5, %20, %17, %13 : none, none, none, none
  %24 = buffer [2] seq %23 : none
  %25 = constant %11 {value = 3.000000e+00 : f64} : f64
  %26 = buffer [2] seq %25 : f64
  %27 = constant %10 {value = 2.000000e+00 : f64} : f64
  %28 = buffer [2] seq %27 : f64
  %29 = constant %9 {value = 1.000000e+00 : f64} : f64
  %30 = buffer [2] seq %29 : f64
  %31 = constant %8 {value = 2 : index} : index
  %32 = buffer [2] seq %31 : index
  %33 = constant %7 {value = 1 : index} : index
  %34 = buffer [2] seq %33 : index
  %35 = constant %6 {value = 0 : index} : index
  %36 = buffer [2] seq %35 : index
  %dataResult, %addressResult = store [%36] %30, %4 : index, f64
  %37 = buffer [2] seq %addressResult : index
  %38 = buffer [2] seq %dataResult : f64
  %39 = join %3, %21 : none, none
  %40 = buffer [2] seq %39 : none
  %dataResult_0, %addressResult_1 = store [%34] %28, %40 : index, f64
  %41 = buffer [2] seq %addressResult_1 : index
  %42 = buffer [2] seq %dataResult_0 : f64
  %43 = join %2, %22, %18 : none, none, none
  %44 = buffer [2] seq %43 : none
  %dataResult_2, %addressResult_3 = store [%32] %26, %44 : index, f64
  %45 = buffer [2] seq %addressResult_3 : index
  %46 = buffer [2] seq %dataResult_2 : f64
  return %24 : none
}

hlsinput.mlir:3:12: error: unsupported data type ''f64''
    %cst = arith.constant 3.000000e+00 : f64
           ^
hlsinput.mlir:3:12: error: unsupported data type ''f64''
    %cst = arith.constant 3.000000e+00 : f64
           ^
hlsinput.mlir:3:12: error: unsupported constant type
    %cst = arith.constant 3.000000e+00 : f64
           ^
hlsinput.mlir:3:12: note: see current operation: %50 = "handshake.constant"(%23) <{value = 3.000000e+00 : f64}> : (none) -> f64
hlsinput.mlir:3:12: error: unsupported data type ''f64''
    %cst = arith.constant 3.000000e+00 : f64
           ^
hlsinput.mlir:3:12: error: unsupported constant type
    %cst = arith.constant 3.000000e+00 : f64
           ^
hlsinput.mlir:3:12: note: see current operation: %50 = "handshake.constant"(%23) <{value = 3.000000e+00 : f64}> : (none) -> f64
hlsinput.mlir:3:12: error: unsupported data type ''f64''
    %cst = arith.constant 3.000000e+00 : f64
           ^
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: hlstool --mlir-print-ir-after-all --verilog hlsinput.mlir
 #0 0x00005713c3480d62 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/andre/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:22
 #1 0x00005713c3481175 PrintStackTraceSignalHandler(void*) /home/andre/circt/llvm/llvm/lib/Support/Unix/Signals.inc:798:1
 #2 0x00005713c347e709 llvm::sys::RunSignalHandlers() /home/andre/circt/llvm/llvm/lib/Support/Signals.cpp:105:20
 #3 0x00005713c3480627 SignalHandler(int) /home/andre/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x000072edb9842520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)
 #5 0x00005713c33d84a8 llvm::APInt::APInt(llvm::APInt const&) /home/andre/circt/llvm/llvm/include/llvm/ADT/APInt.h:176:44
 #6 0x00005713c4285389 mlir::IntegerAttr::getValue() const /home/andre/circt/llvm/build/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:436:1
 #7 0x00005713c38f6297 (anonymous namespace)::ConstantConversionPattern::buildModule(circt::handshake::ConstantOp, circt::BackedgeBuilder&, (anonymous namespace)::RTLBuilder&, circt::hw::HWModulePortAccessor&) const /home/andre/circt/lib/Conversion/HandshakeToHW/HandshakeToHW.cpp:1635:26
 #8 0x00005713c393bf13 (anonymous namespace)::HandshakeConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(circt::handshake::ConstantOp, circt::handshake::ConstantOpAdaptor, mlir::ConversionPatternRewriter&) const::'lambda'(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)::operator()(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&) const /home/andre/circt/lib/Conversion/HandshakeToHW/HandshakeToHW.cpp:763:24
 #9 0x00005713c3953fad void llvm::function_ref<void (mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)>::callback_fn<(anonymous namespace)::HandshakeConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(circt::handshake::ConstantOp, circt::handshake::ConstantOpAdaptor, mlir::ConversionPatternRewriter&) const::'lambda'(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)>(long, mlir::OpBuilder&, circt::hw::HWModulePortAccessor&) /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:40
#10 0x00005713c3aab60d llvm::function_ref<void (mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)>::operator()(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&) const /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:62
#11 0x00005713c3a49270 circt::hw::HWModuleOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::StringAttr, circt::hw::ModulePortInfo const&, llvm::function_ref<void (mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)>, mlir::ArrayAttr, llvm::ArrayRef<mlir::NamedAttribute>, mlir::StringAttr) /home/andre/circt/lib/Dialect/HW/HWOps.cpp:787:72
#12 0x00005713c394d0e8 circt::hw::HWModuleOp mlir::OpBuilder::create<circt::hw::HWModuleOp, mlir::StringAttr, circt::hw::ModulePortInfo&, (anonymous namespace)::HandshakeConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(circt::handshake::ConstantOp, circt::handshake::ConstantOpAdaptor, mlir::ConversionPatternRewriter&) const::'lambda'(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)>(mlir::Location, mlir::StringAttr&&, circt::hw::ModulePortInfo&, (anonymous namespace)::HandshakeConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(circt::handshake::ConstantOp, circt::handshake::ConstantOpAdaptor, mlir::ConversionPatternRewriter&) const::'lambda'(mlir::OpBuilder&, circt::hw::HWModulePortAccessor&)&&) /home/andre/circt/llvm/mlir/include/mlir/IR/Builders.h:517:16
#13 0x00005713c393c0e2 (anonymous namespace)::HandshakeConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(circt::handshake::ConstantOp, circt::handshake::ConstantOpAdaptor, mlir::ConversionPatternRewriter&) const /home/andre/circt/lib/Conversion/HandshakeToHW/HandshakeToHW.cpp:751:7
#14 0x00005713c38eabc8 mlir::OpConversionPattern<circt::handshake::ConstantOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/andre/circt/llvm/mlir/include/mlir/Transforms/DialectConversion.h:614:27
#15 0x00005713c532bab0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1682:55
#16 0x00005713c53c1847 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::'lambda'()::operator()() const /home/andre/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:212:59
#17 0x00005713c53c21df void llvm::function_ref<void ()>::callback_fn<mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::'lambda'()>(long) /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:40
#18 0x00005713c333b39a llvm::function_ref<void ()>::operator()() const /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:62
#19 0x00005713c53c5713 void mlir::MLIRContext::executeAction<mlir::ApplyPatternAction, mlir::Pattern const&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pattern const&) /home/andre/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:281:3
#20 0x00005713c53c1fa0 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) /home/andre/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:233:5
#21 0x00005713c532ccb7 (anonymous namespace)::OperationLegalizer::legalizeWithPattern(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1991:46
#22 0x00005713c532c0ed (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:1882:16
#23 0x00005713c532e9b8 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2392:13
#24 0x00005713c532f469 mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:2495:15
#25 0x00005713c5333b21 mlir::applyPartialConversion(llvm::ArrayRef<mlir::Operation*>, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3258:43
#26 0x00005713c5333bb5 mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) /home/andre/circt/llvm/mlir/lib/Transforms/Utils/DialectConversion.cpp:3264:77
#27 0x00005713c38f86c5 convertFuncOp((anonymous namespace)::ESITypeConverter&, mlir::ConversionTarget&, circt::handshake::FuncOp, mlir::OpBuilder&) /home/andre/circt/lib/Conversion/HandshakeToHW/HandshakeToHW.cpp:1952:13
#28 0x00005713c38f8b63 (anonymous namespace)::HandshakeToHWPass::runOnOperation() /home/andre/circt/lib/Conversion/HandshakeToHW/HandshakeToHW.cpp:2003:17
#29 0x00005713c5481fd3 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::'lambda0'()::operator()() const /home/andre/circt/llvm/mlir/lib/Pass/Pass.cpp:523:57
#30 0x00005713c5485c9f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::'lambda0'()>(long) /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:46:40
#31 0x00005713c333b39a llvm::function_ref<void ()>::operator()() const /home/andre/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:62
#32 0x00005713c548beab void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/andre/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:281:3
#33 0x00005713c54823ee mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/andre/circt/llvm/mlir/lib/Pass/Pass.cpp:532:23
#34 0x00005713c54826da mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/andre/circt/llvm/mlir/lib/Pass/Pass.cpp:592:15
#35 0x00005713c54845ba mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/andre/circt/llvm/mlir/lib/Pass/Pass.cpp:906:71
#36 0x00005713c5484411 mlir::PassManager::run(mlir::Operation*) /home/andre/circt/llvm/mlir/lib/Pass/Pass.cpp:885:76
#37 0x00005713c3331eef doHLSFlowDynamic(mlir::PassManager&, mlir::ModuleOp, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/andre/circt/tools/hlstool/hlstool.cpp:372:13
#38 0x00005713c3332b0d processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/andre/circt/tools/hlstool/hlstool.cpp:501:15
#39 0x00005713c3332d29 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/andre/circt/tools/hlstool/hlstool.cpp:530:60
#40 0x00005713c3332eea processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/andre/circt/tools/hlstool/hlstool.cpp:546:71
#41 0x00005713c33331e7 executeHlstool(mlir::MLIRContext&) /home/andre/circt/tools/hlstool/hlstool.cpp:583:13
#42 0x00005713c3333430 main /home/andre/circt/tools/hlstool/hlstool.cpp:639:39
#43 0x000072edb9829d90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16
#44 0x000072edb9829e40 call_init ./csu/../csu/libc-start.c:128:20
#45 0x000072edb9829e40 __libc_start_main ./csu/../csu/libc-start.c:379:5
#46 0x00005713c3330c75 _start (/home/andre/circt/build/bin/hlstool+0x1f08c75)
